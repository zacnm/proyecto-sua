package sua.autonomouscar.mapeklite.adaptation.resources.rules;

import java.util.HashMap;

import org.osgi.framework.BundleContext;

import es.upv.pros.tatami.adaptation.mapek.lite.ARC.structures.systemconfiguration.interfaces.IRuleComponentsSystemConfiguration;
import es.upv.pros.tatami.adaptation.mapek.lite.artifacts.components.AdaptationRule;
import es.upv.pros.tatami.adaptation.mapek.lite.artifacts.interfaces.IKnowledgeProperty;
import es.upv.pros.tatami.adaptation.mapek.lite.exceptions.analyzing.RuleException;
import es.upv.pros.tatami.adaptation.mapek.lite.helpers.BasicMAPEKLiteLoopHelper;
import es.upv.pros.tatami.adaptation.mapek.lite.helpers.SystemConfigurationHelper;
import es.upv.pros.tatami.adaptation.mapek.lite.structures.systemconfiguration.interfaces.IRuleSystemConfiguration;
import es.upv.pros.tatami.osgi.utils.interfaces.ITimeStamped;
import es.upv.pros.tatami.osgi.utils.logger.SmartLogger;

import sua.autonomouscar.infraestructure.interaction.ARC.HapticVibrationARC;
import sua.autonomouscar.infraestructure.interaction.ARC.NotificationServiceARC;
import sua.autonomouscar.mapeklite.adaptation.resources.enums.EDireccion;
import sua.autonomouscar.mapeklite.adaptation.resources.enums.EFuncionConduccion;
import sua.autonomouscar.mapeklite.adaptation.resources.knowledge.KnowledgeId;

public class ErrorDistanceSensorAdaptationRule extends AdaptationRule {
	
	protected static SmartLogger logger = SmartLogger.getLogger(ErrorDistanceSensorAdaptationRule.class);
	public static String ID = "Regla Error Sensor Distancia";
	
	IKnowledgeProperty kp_ErrorSensorDistanciaActual = null;
	IKnowledgeProperty kp_ErrorSensorDistanciaAnterior = null;
	IKnowledgeProperty kp_FuncionConduccion = null;

	public ErrorDistanceSensorAdaptationRule(BundleContext context) {
		super(context, ID);
		this.setListenToKnowledgePropertyChanges(KnowledgeId.ERROR_SENSORES_DISTANCIA_ACTUAL);

		kp_ErrorSensorDistanciaActual = BasicMAPEKLiteLoopHelper.getKnowledgeProperty(KnowledgeId.ERROR_SENSORES_DISTANCIA_ACTUAL);
		kp_ErrorSensorDistanciaAnterior = BasicMAPEKLiteLoopHelper.getKnowledgeProperty(KnowledgeId.ERROR_SENSORES_DISTANCIA_ANTERIOR);
		kp_FuncionConduccion = BasicMAPEKLiteLoopHelper.getKnowledgeProperty(KnowledgeId.FUNCION_CONDUCCION_ACTUAL);
	}

	@Override
	public boolean checkAffectedByChange(IKnowledgeProperty property) {
		
		if (kp_ErrorSensorDistanciaActual == null || kp_ErrorSensorDistanciaActual.getValue() == null ||
				kp_ErrorSensorDistanciaAnterior == null || kp_ErrorSensorDistanciaAnterior.getValue() == null ||
				kp_FuncionConduccion == null || kp_FuncionConduccion.getValue() == null) {
			return false;
		}
		
		return true;
	}
	
	@Override
	public IRuleSystemConfiguration onExecute(IKnowledgeProperty property) throws RuleException {
	
		HashMap<EDireccion, Boolean> erroresActuales = (HashMap<EDireccion, Boolean>) kp_ErrorSensorDistanciaActual.getValue();
		HashMap<EDireccion, Boolean> erroresAnteriores = (HashMap<EDireccion, Boolean>) kp_ErrorSensorDistanciaAnterior.getValue();
		
		for (EDireccion direccion : erroresActuales.keySet()) {
			boolean errorActual = erroresActuales.get(direccion);
			boolean errorAnterior = erroresAnteriores.get(direccion);
			
			if (errorActual != errorAnterior) {
				
			}
		}
		
		
		
		return nextSystemConfiguration;
	}
	
	private IRuleComponentsSystemConfiguration reemplazarSensorDistanciaPorLIDAR(EDireccion direccion) {
		
		String drivingServiceId = null;
		
		switch ((EFuncionConduccion)kp_FuncionConduccion.getValue()) {
			case L3_CityChauffer:
				drivingServiceId = "driving.L3.CityChauffer";
				break;
			case L3_HighwayChauffer:
				drivingServiceId = "driving.L3.HighwayChauffer";
				break;
			case L3_TrafficJamChauffer:
				drivingServiceId = "driving.L3.TrafficJamChauffer";
				break;
			case L2_AdaptiveCruiseControl:
				drivingServiceId = "driving.L2.AdaptiveCruiseControl";
				break;
			case L2_LaneKeepingAssist:
				drivingServiceId = "driving.L2.LaneKeepingAssist";
				break;
			case L1_AssistedDriving:
				drivingServiceId = "driving.L1.AssistedDriving";
				break;
			default:
				logger.error("No se puede reemplazar el sensor de distancia por LIDAR en la funci칩n de conducci칩n actual: " + kp_FuncionConduccion.getValue());
				return null;
		}
		
		String sensorReq = null;
		
		switch (direccion) {
			case FRONT:
				sensorReq = "LIDAR-FrontDistanceSensor";
				break;
			case REAR:
				sensorReq = "LIDAR-RearDistanceSensor";
				break;
			case LEFT:
				sensorReq = "LIDAR-LeftDistanceSensor";
				break;
			case RIGHT:
				sensorReq = "LIDAR-RightDistanceSensor";
				break;
			default:
				logger.error("Direcci칩n no v치lida para reemplazar el sensor de distancia por LIDAR: " + direccion);
				return null;
		}
		
		IRuleComponentsSystemConfiguration nextSystemConfiguration = SystemConfigurationHelper.createPartialSystemConfiguration(this.getId() + "_" + ITimeStamped.getCurrentTimeStamp());

		SystemConfigurationHelper.bindingToAdd(nextSystemConfiguration, 
				"interaction.NotificationService", "1.0.0", NotificationServiceARC.REQUIRED_SERVICE,
				"interaction.Seat.Driver", "1.0.0", HapticVibrationARC.PROVIDED_MECHANISM);

		return nextSystemConfiguration;
	}
	
	private IRuleComponentsSystemConfiguration reemplazarLIDARPorSensorDistancia(EDireccion direccion) {
		
		IRuleComponentsSystemConfiguration nextSystemConfiguration = SystemConfigurationHelper.createPartialSystemConfiguration(this.getId() + "_" + ITimeStamped.getCurrentTimeStamp());

		SystemConfigurationHelper.bindingToRemove(nextSystemConfiguration, 
				"interaction.NotificationService", "1.0.0", NotificationServiceARC.REQUIRED_SERVICE,
				"interaction.Seat.Driver", "1.0.0", HapticVibrationARC.PROVIDED_MECHANISM);

		return nextSystemConfiguration;
	}

	
}
